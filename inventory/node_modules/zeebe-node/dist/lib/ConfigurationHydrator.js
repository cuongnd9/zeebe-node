"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
class ConfigurationHydrator {
    static configure(gatewayAddress, options) {
        // ConfigurationHydrator.warnOnAmbiguousConfig()
        const configuration = {
            hostname: 'localhost',
            port: '26500',
            ...ConfigurationHydrator.readBasicAuthFromEnvironment(),
            ...ConfigurationHydrator.readOAuthFromEnvironment(gatewayAddress),
            ...ConfigurationHydrator.getGatewayFromEnvironment(),
            ...ConfigurationHydrator.decodeConnectionString(gatewayAddress),
            ...ConfigurationHydrator.getCamundaCloudConfig(options),
            ...ConfigurationHydrator.readTLSFromEnvironment(options),
            ...ConfigurationHydrator.getEagerStatus(options),
        };
        return configuration;
    }
    static readTLSFromEnvironment(options = {}) {
        var _a;
        const useTLS = (_a = options.useTLS) !== null && _a !== void 0 ? _a : ConfigurationHydrator.getTlsFromEnv();
        return {
            useTLS,
        };
    }
    static readOAuthFromEnvironment(gatewayAddress) {
        const clientId = ConfigurationHydrator.getClientIdFromEnv();
        const clientSecret = ConfigurationHydrator.getClientSecretFromEnv();
        const audience = process.env.ZEEBE_TOKEN_AUDIENCE;
        const authServerUrl = process.env.ZEEBE_AUTHORIZATION_SERVER_URL;
        const clusterId = process.env.ZEEBE_CAMUNDA_CLOUD_CLUSTER_ID;
        const isCamundaCloudShortcutConfig = clusterId || (clientId && clientSecret && !audience);
        if (isCamundaCloudShortcutConfig) {
            return ConfigurationHydrator.readCamundaClusterConfFromEnv(gatewayAddress);
        }
        return clientId && clientSecret && audience && authServerUrl
            ? {
                oAuth: {
                    audience,
                    cacheOnDisk: true,
                    clientId: clientId,
                    clientSecret,
                    url: authServerUrl,
                },
                useTLS: true,
            }
            : {};
    }
    static readBasicAuthFromEnvironment() {
        const password = process.env.ZEEBE_BASIC_AUTH_PASSWORD;
        const username = process.env.ZEEBE_BASIC_AUTH_USERNAME;
        return password && username
            ? {
                basicAuth: {
                    password,
                    username,
                },
            }
            : {};
    }
    static readCamundaClusterConfFromEnv(explicitGateway) {
        if (explicitGateway) {
            return {};
        }
        // We can either take a simple clusterId, or else the whole Zeebe Address
        // This env var is Node-client specific
        const clusterId = process.env.ZEEBE_CAMUNDA_CLOUD_CLUSTER_ID;
        // This env var is compatible with zbctl and the Java and Go clients
        const zeebeAddress = ConfigurationHydrator.getZeebeAddressFromEnv();
        const name = clusterId ? clusterId : zeebeAddress;
        const hostname = `${ConfigurationHydrator.justClusterId(name)}.zeebe.camunda.io`;
        const audience = hostname;
        const clientId = ConfigurationHydrator.getClientIdFromEnv();
        const clientSecret = ConfigurationHydrator.getClientSecretFromEnv();
        const url = process.env.ZEEBE_AUTHORIZATION_SERVER_URL ||
            ConfigurationHydrator.CAMUNDA_CLOUD_AUTH_SERVER;
        return clientId
            ? {
                hostname,
                oAuth: {
                    audience,
                    cacheDir: undefined,
                    cacheOnDisk: true,
                    clientId: clientId,
                    clientSecret: clientSecret,
                    url,
                },
                port: '443',
                useTLS: true,
            }
            : {};
    }
    static getGatewayFromEnvironment() {
        // ZEEBE_GATEWAY_ADDRESS is for backward compatibility. ZEEBE_ADDRESS is for compatibility with
        // the Java / Go clients (including zbctl)
        const connectionString = ConfigurationHydrator.getZeebeAddressFromEnv();
        return connectionString
            ? ConfigurationHydrator.decodeConnectionString(connectionString)
            : {};
    }
    static decodeConnectionString(connectionString) {
        if (!connectionString) {
            connectionString = ConfigurationHydrator.getZeebeAddressFromEnv();
            if (!connectionString) {
                return {};
            }
        }
        const includesProtocol = connectionString.includes('://');
        const gatewayAddress = includesProtocol
            ? connectionString
            : `zeebe://${connectionString}`;
        const url = url_1.parse(gatewayAddress);
        url.port = url.port || ConfigurationHydrator.DEFAULT_GATEWAY_PORT;
        url.hostname = url.hostname || url.path;
        return {
            hostname: url.hostname,
            port: url.port,
        };
    }
    static getCamundaCloudConfig(options = {}) {
        if (options.camundaCloud) {
            const { camundaCloud } = options;
            const clusterId = ConfigurationHydrator.justClusterId(camundaCloud.clusterId);
            const configuration = {
                ...options,
                hostname: `${clusterId}.zeebe.camunda.io`,
                oAuth: {
                    audience: `${clusterId}.zeebe.camunda.io`,
                    cacheDir: camundaCloud.cacheDir,
                    cacheOnDisk: camundaCloud.cacheOnDisk !== false,
                    clientId: camundaCloud.clientId,
                    clientSecret: camundaCloud.clientSecret,
                    url: ConfigurationHydrator.CAMUNDA_CLOUD_AUTH_SERVER,
                },
                port: '443',
                useTLS: true,
            };
            return configuration;
        }
        return options;
    }
    static justClusterId(maybeClusterId) {
        // 'Be liberal in what you accept and conservative in what you emit'
        // Here we account for users pasting in either the expected clusterId
        // or the entire Zeebe ContactPoint from the Cloud Console.
        return maybeClusterId
            ? maybeClusterId.split('.zeebe.camunda.io')[0]
            : undefined;
    }
    static getEagerStatus(options) {
        return {
            eagerConnection: (process.env.ZEEBE_NODE_EAGER_CONNECT || 'false').toLocaleLowerCase() === 'true' ||
                (options === null || options === void 0 ? void 0 : options.eagerConnection) === true,
        };
    }
}
exports.ConfigurationHydrator = ConfigurationHydrator;
ConfigurationHydrator.getLogLevelFromEnv = () => process.env.ZEEBE_NODE_LOG_LEVEL;
ConfigurationHydrator.DEFAULT_GATEWAY_PORT = '26500';
ConfigurationHydrator.CAMUNDA_CLOUD_AUTH_SERVER = 'https://login.cloud.camunda.io/oauth/token';
ConfigurationHydrator.getClientIdFromEnv = () => process.env.ZEEBE_CLIENT_ID;
ConfigurationHydrator.getZeebeAddressFromEnv = () => process.env.ZEEBE_ADDRESS || process.env.ZEEBE_GATEWAY_ADDRESS;
ConfigurationHydrator.getClientSecretFromEnv = () => process.env.ZEEBE_CLIENT_SECRET;
ConfigurationHydrator.getTlsFromEnv = () => (process.env.ZEEBE_SECURE_CONNECTION || '').toLowerCase() === 'true'
    ? true
    : (process.env.ZEEBE_SECURE_CONNECTION || '').toLowerCase() ===
        'false'
        ? false
        : undefined;
//# sourceMappingURL=ConfigurationHydrator.js.map